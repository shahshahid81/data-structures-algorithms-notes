```c++
#include <bits/stdc++.h>

using namespace std;

int main()
{
    // map stores key uniquely in sorted order
	// Implemented internally as self balanced binary tree, NO o(1) access time
    map<int, int> m;
    map<int, pair<int, int>> mp;
    map<pair<int, int>, int> mp2;

    // key: 1, value: 2
    m[1] = 2;

    // key: 3, value: 1
    m.emplace(3, 1);

    // key: 2, value: 4
    m.insert({2, 4});
    m.insert({7, 10});

    mp2[{3, 1}] = 2;

    for (auto it : m)
    {
        cout << it.first << " " << it.second << endl;
    }

    cout << m[1] << endl;

    // Returns 0 since there is no 5 as key, use find and compare it with end to check existence of key
    cout << m[5] << endl;

    map<int, int>::iterator it = m.find(3);
    cout << it->second << endl;

    auto it2 = m.find(5);
    cout << std::boolalpha << (it2 == m.end()) << endl;

    auto lower = m.lower_bound(2);
    cout << "lower: (" << lower->first << " : " << lower->second << ")" << endl;

    auto upper = m.upper_bound(3);
    cout << "upper: (" << upper->first << " : " << upper->second << ")" << endl;

    // Definitions:
    // lower_bound(value): Finds the first element ≥ value.
    // upper_bound(value): Finds the first element > value.

    // Sorted Array:
    // [1, 3, 5, 7, 9, 11, 13]

    // lower_bound(5) → 5
    // (The value 5 is present, so the lower bound is 5.)

    // upper_bound(5) → 7
    // (The first element > 5 is 7.)

    // lower_bound(6) → 7
    // (The first element ≥ 6 is 7.)

    // upper_bound(6) → 7
    // (The first element > 6 is 7.)

    // lower_bound(1) → 1 (start)
    // (The first element ≥ 1 is 1.)

    // upper_bound(1) → 3
    // (The first element > 1 is 3.)

    // lower_bound(13) → 13 (end)
    // (The first element ≥ 13 is 13.)

    // upper_bound(13) → end()
    // (There is no element > 13, so it returns end().)

    // Removes key 2
    m.erase(2);

    // Removes range 3 to 6
    m.erase(m.find(3), m.find(7));

    cout << m.size() << endl;
    cout << m.empty() << endl;

    map<int, int> m1, m2;
    m1.swap(m2);
}
```

Output:
```
1 2
2 4
3 1
7 10
2
0
1
false
lower: (2 : 4)
upper: (5 : 0)
1 2
2 4
3 1
5 0
7 10
1 2
7 10
2
false

```